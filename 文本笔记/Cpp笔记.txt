1.变量存在的意义：方便我们管理内存空间。 赋值操作跟C一样。

2.常量：#define 定义   ，或者用const修饰一个变量

3.变量命名第一个元素不能是数字，区分大小写

4.数据类型：short:  -pow(2,15)~pow(2,15)-1  
                      int:  -pow(2,31)~pow(2,31)-1
	           long:   在linux,win32位环境下和int一样   ， 在win64位环境下是pow(2,63)~pow(2,63)-1
	   long long:  -pow(2,63)~pow(2,63)-1
            1.24这种默认是double类型，1.24f默认是float类型
		float四字节，double八字节      3e2意思是3 x 10的2次方

5.有string 类型 直接 string a="pxd"       有bool类型  直接bool  a=true  或者  false   只占用一个字节

6.      常量指针，指针指向的是个常量，指针指向的值不能更改。  const int * a;
        指针常量，指针本身是个常量，指针指向不能修改，指针指向的值可以更改。  int * const a;
  常量指针常量，指针本身是个常量 ，指针指向的东西也是个常量。  const int * const a;

7.内存分区模型：(1)代码区：存放CPU的机器指令。代码区是共享的，对于频繁执行的程序，内存中只有这一份。代码区是只读的，防止程序意外地修改了代码
			(2)全局区：存放全局变量(函数外面的)和静态变量(static修饰的)，还有，全局常量(外面的，顺带const修饰) ，字符串常量(指的是char  * a="abcde"  这种格式)（“abcde”直接写这个也是个字符串常量）
					程序结束后由操作系统释放     （注意：只要是函数里面的变量不管带不带const'修饰都不在全局区）
			(3)栈区：由编译器自动分配释放，存放函数的参数值，局部变量等     （注意：不要返回函数中局部变量的地址，因为函数结束后，内存由系统销毁）
			(4)堆区:  由程序员分配释放，如果程序员不释放，程序结束后由系统自动释放

7*.   str == Book_p->PeopleArr[i].name   string类型可以像那样直接比。

8.new关键字      这么用：int *p = new int(10);    在堆区创建了一个数据，  *p的结果是10.      开辟数组  int * p=new int[10];

9.  delete  用来释放空间    delete  p;  释放一个数据    delete  [ ]p释放一块大空间

10.引用：给变量起别名       int a = 1;    int &b = a;   此时改变b的值也就改变了a的值。   引用必须要初始化 ，单挂int &b；是错误的  ，必须int &b=a；这种才行 。
		一旦初始化了，比如  int &b=a;  就不能更改引用了  ，比如int &b =c；是错误的
		引用交换：void swap(int &a,int &b)     因为形参是实参的别名，所以形参的改变可以修改实参数
				{
    					int temp = a;
    					a = b;
    					b = temp;
				}
10*.引用的本质 ：int & b=a;   本质是  int * const b=&a; (这里由编译器实现)
				b=20;     本质是    *b=20;(编译器实现)

11.常量引用：用来修饰形参，防止误操作
			int & ref =10;  //这种语法是不被允许的 ， 但是加上const  ,const int & ref=10;是允许的
			编译器做出如下修改：int temp = 10;  const int & ref =temp;

11*.常量引用作为参数 ：比如void print(const int & a)    参数本质是个  常量指针常量  ，指向不能改，指向的值也不能改，防止误操作

12.c++支持带有默认值的函数，比如 int rel(int a,int b=1,int c=2)  ,注意调用时，b,c位置的参数可以不填，a的位置必须填 。形参列表中，从一个参数开始有默认值，后续的形参必须也有默认值，比如不能  int rel(int a,int b=1,int c)，，必须给c也赋默认值

12*.如果要分文件写默认值函数的话，请在声明中给出默认值，实现部分的函数头不要给默认值 。   声明和实现只能有一个给默认值

13.占位参数  ：比如  void fun (int a,int)      调用时必须给两个值  fun(10,10)   就是说只传一个类型名的位置，必须有值，但这个值取不到，用不了，就占个位置。

13*.占位参数也可以有默认值，比如 void fun(int a,int =10)      那么可以直接  fun(10)  只有类型名的参数位置也可以不用写了

14.函数重载：可以让函数名相同，提高程序复用性。 满足条件：1.函数在相同的作用域(通常是满足的，都是全局函数，不在main里面) 2.函数名字一样 3.形参列表必须有所差别，这个差别不包括默认值上的差别，也不包括同类型占位参数和普通参数上的区别，不包括形参名字的区别，不包括返回类型的区别。  

14*.只有在引用作为参数时，const 修饰才会引起区别。比如int fun(const int & a)     和 int fun(int & a)是可以重装载的。并且 const int & a=10,可以赋默认值   int & a不可以有默认值。

14*. int a=10视为变量，const int a=10视为常量，单个10也视为常量

14*.void fun(int a,int b=0)     void fun(int a)      当使用fun(5);语句时，编译器无法判断调用了哪个函数，也就无法重装载。如果是fun(5,5)就可以产生区别，允许重装载，但是参数默认值也就失去了意义。